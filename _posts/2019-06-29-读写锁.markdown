---
layout: post
title:  "[笔记]读写锁"
date:   2019-06-29 +0800
categories: coding programming 笔记 读写锁
---

在Twitter上看到一篇介绍[读写锁实现](https://eli.thegreenplace.net/2019/implementing-reader-writer-locks/)的文章，今天抽空把它记下来。

读写锁的存在，是为了让多个线程能够同时读取受保护的资源，仅在需要修改资源时，才使用写锁独占资源。相比于使用Mutex每次只让一个线程访问资源的方式，读写锁控制的资源访问方式更高效。

# Naive读写锁

最简单的想法就是用一个计数器记录有多少个读者正在持有读写锁，只有计数器为0时，才允许写者访问受保护的资源。

这个实现还需要一个Mutex，它起到两个作用。

Mutex的第一个作用是保证对计数器的加减操作是互斥的。每个读者获取读写锁时，先拿到Mutex，对计数器加1，再释放Mutex。读者释放读写锁时，在Mutex的保护下，对计数器减1。

Mutex的第二个作用是，当写者正在访问受保护的资源时，通过占用Mutex，防止其它读者、写着同时访问资源。写者获取读写锁时，通过spin的形式，在每轮迭代中，在Mutex保护下，通过计数器判断是否有读者正在访问受保护的资源，如果有，就放弃Mutex，进行下一轮迭代；如果没有读者，就跳出spin，一直持有Mutex，直到对资源访问完毕。

# 让写者通过conditional variable等待读者

前一个实现中的写者，通过spin的方式等待，直到资源不再被读者使用。spin的方式会造成CPU空转。所以通过conditional variable (cv)的方式让写者进行等待更好。

此时，写者如果发现有其它读者在操作共享资源，就通过cv进入等待状态。读者如果在释放锁时，没有其它读者，就通过cv唤醒写者。写者释放锁时，也要通过cv操作唤醒可能存在其它写者。

# 通过semaphore实现

通过semaphore保护共享资源。假设系统能够容纳的最大读者数量是N，那么就将semaphore的值初始化为N。读者的加锁和解锁是对semaphore的减1和加1操作，写者的加解锁是对semaphore的减N和加N操作。也就是说，只有系统中没有读者时，写者的加锁减N操作才能成功。

# 对写者友好的简单读写锁

以上的实现，都是对读者友好的。只要系统中存在读者，新来的读者就能得到锁。以下的实现，是写者友好的。当系统中有写者等待获取锁时，新来的读者不会去获取读锁，而是和写者一样，等待系统中已获取读锁的读者全部退出，再与写者一起竞争锁。

接着之前cv实现的读写锁。在锁的结构中加一个bool变量，用于指示系统中是否有写者在等待获取锁。

读者在获取锁时，如果发现有写者等待，就通过cv进入等待状态。当读者释放锁时，如果没有其它读者持有锁，就通过cv广播唤醒所有等待状态的读者和写者。

写者稍微复杂一些。写者首先通过bool变量检查系统中有没有其它写者，有就通过cv进入等待，直到没有其它写者。被唤醒后，再等到持有读锁的读者释放掉所有锁后，就持有了写锁。写者释放锁时，要将bool变量修改成没有写者的状态，然后释放写锁。

# Go语言读写锁实现

前面提到了用semaphore实现的读写锁。Go语言的读写锁中，用原子变量取代了semaphore；然后Mutex仅用于写者之间的互斥。

同样原子变量的值被初始化为N。

写者在获取锁时，先拿到Mutex，然后将原子变量减去N：
1. 如果等于0，则获取锁成功。
2. 如果不等于0，说明有有读者，计算出有多少个读者，将读者数量保存在锁的状态中。然后进入等待状态。

读者在获取锁时，对原子变量加1：
1. 如果大于0，说明没有写者，获取锁成功；
2. 如果小于等于0，说明有写者，进入等待状态。

读者释放锁时，对原子变量减1:
1. 如果大于等于0，没有写者，无需其它操作；
2. 如果小于0，说明有写者在等待状态，唤醒等待中的写者。由于Mutex的原因，系统中只能有一个处于等待状态的写者，所以只能由最后一个释放锁的读者唤醒，这是写者在等待时，将读者数量保存在锁的状态中的原因。每当读者释放锁时，读者数量减1，减为0时，就是最后一个读者，由它唤醒写者。

写者释放锁时，对原子变量加N，唤醒所有等待状态的读者，然后释放Mutex。
